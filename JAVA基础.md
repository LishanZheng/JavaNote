

## 基本数据类型

int ：4个字节  byte 1个字节 short 2个字节

long 8个字节 float 4个字节 double 8个字节

char 2个字节 



## 重写和重载

#### 重写

是子类继承父类后，重写父类的方法，参数列表一致、返回值一致、访问修饰符不能高于父类。

#### 重载

是同一个类中，同名方法的重载，方法名字一样，参数列表不一样、返回值可以不一样、



## HashCode 和 equals

Hashcode() 是散列码，确定对象在哈希表中的位置。

​	当需要把对象加入哈希表中时，会先判断当前对象的哈希码是否存在

​		存在：进行equals来进一步确认，相同就不插入，不相同就重新散列到其他位置

​		不存在：直接放入即可。

​	前提是：当equals相同的时候，hashcode一定要相同，不然就会矛盾。

#### hashcode和equals的作用

​	当hashcode相同时，对象可能不一样需要进一步equals。

​	当hashcode不同时，对象一定不同。



##  String、StringBuffer、Stringbuilder的区别

#### 可变性

​	String的字符数组是用private和final修饰，且没有提供修改字符数组的方法

​	Stringbuilder和Stringbuffer字符数组有提供方法进行修改。都继承于AbstractStringBuilder

#### 线程安全性

String和StringBuffer都是线程安全

	1. String是不可修改的，可以理解为常量，线程安全
	1. StringBuffer的修改方法和调用方法都加了同步锁，也是线程安全

StringBuilder不是线程安全的

#### 使用总结

少量用String，大量单线程用Stringbuilder，大量多线程用StringBuffer	



#### String.intern方法

intern是一个本地方法，将对象的字符串对象的引用保存到字符串的常量池中。若字符串中有该对象的引用，则返回，没有就先创建后返回。



#### String不可变的原因？

1. String的字符数组由private和final修饰，且没有提供修改数组的方法。
2. String类本身也被final修饰，不能被继承后破坏不可变。



#### 为什么改用Byte数组？

1. JAVA9之后，String、StringBuilder、StringBuffer都是用 byte数组来存储字符，本质上因为byte数组一个字符只需要8个bit，而char需要16个bit，若字符没有超出Latin-1的范围用byte就可以节省一半的空间，若有超出的字符，那么就和原来一样。

#### 字符串常量池，JDK6 -JDK7

JDK6之前String的字符串常量池位于perm，是类静态区域，多次调用intern会导致这个区域内存溢出。JDK7把这个区域移动到 JAVA Heap中了



## 异常

Exception和Error：Exception是程序可以捕获和处理的异常，Error是无法处理的错误，如虚拟机内存不足。



## 反射

#### 为什么反射比较慢？

1. 编译器无法优化代码，它无法了解你代码在做什么
2. 反射需要进行安全检查、如检查是否有无参构造、是否有权限访问无参构造、调用者是否有权限使用反射等。
3. 反射在发现调用的对象上比较慢，如通过名称匹配类，匹配方法。

#### 反射的优点和缺点

优点：使用起来比较方便，各种框架都可以开箱即用。

缺点：反射比较慢，但对于很多框架来说影响不大。 反射会带来一些安全问题，比如它会无视范型的类型检查。



## 注解

是一种特殊的注释，本质上是继承了特殊的annotation的特殊接口。

解析方式：

	1. 编译期解析，如@Override会在编译阶段检查是否重写父类方法。
	1. 运行时解析，比如Spring框架中的注解，在运行时通过反射进行处理



## 代理

### 静态代理

实现步骤：

1. 定义接口和实现类
2. 定义代理类同样实现接口
3. 目标类注入到代理类，在代理类的实现中进行额外操作并调用原来的方法。



### 动态代理

#### JDK动态代理

实现步骤

1. 定义接口类和实现
2. 定义代理类实现InvocationHandler，实现invoke方法。在invoke方法中通过反射调用原生方法并进行额外操作。
3. 通过Proxy.newProxyInstance(classLoader, class<>Interfaces, InvocationHandler) 方法创建代理对象，返回的是Object，需要转化为接口类。

##### JDK的致命缺点是只能对实现接口的类进行代理，这个缺点可以通过CGLIB代理消除

#### CGLIB动态代理

实现步骤

1. 实现一个类
2. 实现一个拦截类实现MethodInterceptor。实现intercept方法，方法里通过调用method.invokeSuper来调用原生方法，并加入额外操作
3. 调用时，新建enhancer类，注入（setClassLoader)类加载器、(setSuperClass)被代理类、(setCallback)拦截方法。enhancer.create()创建对象。对象调用方法。



#### 对比JDK动态代理和CGLIB动态代理

1. JDK动态代理只能代理实现了接口的类或直接代理接口，而CGLIB可以直接代理未实现任何接口的类。
2. CGLIB是生成一个被代理类的子类拦截代理类的方法调用，所以对于final对象没有办法代理。
3. 效率相比，JDK动态代理高于CGLIB动态代理



#### CAS机制（Compare And Swap）

属于乐观锁

Compare：先比较预期值和实际值，若相同才会进行下一步

Swap：替换，把实际值替换为新的值

缺点：

1. CPU压力较大，在高并发的情况下，多个线程尝试更新一个变量，又一直失败，会导致CPU带来很大压力。
2. 只能对一个变量进行原子性更新，对一个代码块只能用synchronize了



#### 引用

##### 强引用

在项目中用new对象生成的，都是强引用，除非是被显示的置null。否则不会被垃圾回收自动回收



## 并发编程

### 线程与进程

#### 进程

进程是一个程序的运行过程，系统运行程序的基本单位。

#### 线程

线程是比进程更小的执行单位，一个进程可以有多个线程。

不同：

1. 同一个进程的线程共享进程的方法区和堆。
2. 每个线程有自己的虚拟机栈、本地方法栈、程序计数器。
3. 线程之间切换的代价比进程小。

#### 为什么线程的虚拟机栈、程序计数器、本地方法栈是私有？

因为要避免线程执行时的局部变量不被其他线程访问。

#### 线程的生命周期和状态

线程有6个状态：

1. New 初始状态，线程被创建，但是还没调用start方法。
2. Runnable 运行状态，线程正在被执行，（包括线程的运行状态和就绪状态）
3. Blocked 阻塞状态，线程被锁给阻塞。
4. Waiting 等待状态，线程等待其他线程的操作比如通知或者中断。
5. Time_Waiting 超时等待状态，线程过一段时间后会自动恢复。
6. Terminated 中止状态，线程已经执行完成。

#### 线程死锁

* 死锁产生条件
  * 互斥条件：资源任一时刻只能有一个线程占用。
  * 请求与保持条件：占有部分资源的线程请求新资源被阻塞后，之前占有的资源仍然占有。
  * 不剥夺条件：还没运行完毕的线程，已经持有的资源在没有运行完毕之前不会被剥夺。
  * 循环等待条件：若干个线程之间形成一种头尾相连的循环等待资源情况。

* 死锁的预防，破坏死锁产生条件
  * 破坏请求与保持条件：一次性请求所有资源。
  * 破坏不剥夺条件：当占有其他资源的线程请求新的资源没有被满足时，就释放之前占有的资源。
  * 破坏循环等待条件：按照某种顺序请求资源，释放资源的时候按照反序。

#### 线程sleep和wait的 异同点

不同点：

1. sleep不会释放锁，wait会释放锁
2. sleep会在一定时间后自动苏醒，wait需要等待其他线程的notify才会苏醒（也可以通过wait（时间）来苏醒）
3. sleep用于暂停执行，wait用来线程之间的通信/交互。

相同点：

1. 都可以用来暂停线程。

#### 执行start() 会调用run方法，和直接调用run方法有什么不同？

start执行后会进行线程的初始化，完成后在调用run方法执行。

直接调用run方法会直接把run方法作为普通方法执行，不是多线程。

#### 线程提交任务的不同方式

Runnable和Callable的区别

1. Runnable不会返回结果和异常，Callable会返回结果和异常。

execute和submit的区别

1. Execute方法用于提交不需要返回值的方法，所以无法判断线程是否执行成功。
2. submit方法可以提交需要有返回值的方法，会返回一个Future对象，通过这个对象可以获取线程的执行信息。

### 线程池

#### 基本参数

1. corePoolSize，核心线程数，最小的可以运行的线程数
2. maximumPoolSize，可以运行的最大线程数量。
3. workQueue，线程队列，当核心线程运行满了，新来的任务就会被放到线程队列。
4. keepAliveTime，当线程池中的线程数量大于核心线程数量时，如果线程空闲时间超过来keepAliveTime则会被回收销毁。
5. timeUnit，KeepAliveTime的时间单位。
6. threadFactory，executor创建新线程时用到的工厂方法。
7. Handler，拒绝策略，当线程池的线程数量达到最大运行线程数，且等待队列也满了，执行的拒绝策略。
   1. AbortPolicy，抛出RejectedExecutionException拒绝执行异常（默认策略）

#### 线程池的创建流程

新任务提交

1. 首先判断当前线程数是否达到corePoolSize核心线程数，没有就创建线程执行任务。
2. 若达到corePoolSize核心线程数，则判断是否等待队列已满，没有满就放入workQueue等待队列。
3. 若workQueue等待队列已满，则判断是否当前线程数到达maximumPoolSize最大线程数，没有到达则创建线程执行任务。
4. 若到达maximumPoolSize最大线程数。则执行拒绝Handler策略。

#### 好处

1. 降低资源消耗：重复利用已经创建的线程，可以节省线程创建和销毁的开销。
2. 提高响应速度：任务来的时候，不需要创建新线程，可以节约创建线程的时间。
3. 提高线程的可管理性：由统一的线程池来管理线程，可以方便统一分配、调优和监控。

### JAVA并发指令

#### Synchronize

修饰对象

1. 修饰实例方法，*需要获得当前实例对象* 的锁
2. 修饰静态方法，需要获得当前class对象的锁，与实例方法不冲突。实例方法是获取实例对象的锁，静态方法是获取当前类的锁，不是同一个锁。
3. 修饰代码块，获取指定对象的锁，也可以是对象.class 获取指定对象类的锁。

#### Volatile

1. 防止指令重排
2. 变量可见性

#### Syn和Vol的区别

1. Syn可以用于代码块、方法。Vol只能用于变量。Vol可以用于轻量级的线程同步
2. Vol可以保证数据的可见性，但不能保证数据的原子性。Syn两者都可以保证。
3. Vol用于多个线程之间变量的共享可见性，Syn用于多个线程之间资源的同步性



### AQS 

AQS是用来构建锁和同步器的框架。（AbstractQueuedSynchronizer）

#### AQS的原理

当被请求的资源是空闲，就将当前的线程变为有效工作线程，并将资源的状态改为锁定状态。

若被请求的资源是被锁定的，就需要一套线程阻塞唤醒的锁分配机制。（AQS使用的是CLH队列锁实现的，将请求不到资源的线程放入队列中）

#### AQS的资源共享方式

1. 独占式：资源只能由一个线程获取，锁包括两种
   1. 公平锁，按照队列顺序，先到的先获取
   2. 非公平锁，不按照队列顺序，谁先抢到锁资源归谁。
2. 共享式：多个线程可以公用这个资源。如CountDownLatch



### ThreadLocal

####  ThreadLocal.set详解

通过hash计算出要存的下标。

1. 数据为空，直接放在这个位置。

2. 数据不为空，但是key值一样。直接更新。

3. 数据不为空，且key值不一样，向后遍历

   1. 遇到key值过期的entry（调replaceStaleEntry方法)

      staleSlot=当前index 

      1. 从过期位置向前寻找，直到entry为空的位置停止。（更新slotToExpunge，表示需要清理的过期数据的起始下标）
      2. 寻找完毕后从staleSlot位置开始向后找key相同的元素，
         1. 找到key值一样的就更新，并且交换staleSlot和它的位置。
         2. 没找到值一样的，找到entry为null就停止。替换staleSlot位置上的entry为当前新的。
      3. 从staleToExpunge开始向后清理。
      4. 返回

   2. 没有遇到key值过期的entry

      1. key值一样就更新
      2. 遇到了空值，表示是替换操作。
         1. 先进行一次启发式清理工作。
         2. 若没有清理掉数据，且size大于threshold阈值，就会进行rehash操作

#### ThreadLocal.replaceStaleEntry详解

当前位置为staleSlot；清理起始位置slotToExpunge；

要插入的值为<key，value>

1. 先从staleSlot位置往前寻找key == null的位置，直到entry == null 停止。把位置存到slotToExpunge中。
2. 向前遍历结束
   1. slotToExpunge==staleSlot 说明前面没有需要清理的。
   2. slotToExpunge！=staleSlot 说明前面有需要清理的。
3. 从staleSlot位置开始向后遍历，
   1. 遇到key相同,则把staleSlot位置的过期数据存入当前位置，然后把staleSlot位置插入<key，value>，
      1. 如果前面没有要清理的，就从当前位置开始清理（即slotToExpunge = i ) 
      2. 如果前面有需要清理的，
      3. 调用cleanSomeSlots（slotToExpunge），然后返回
   2. 遇到key == null 且 前面没有要清理的，则把slotToExpunge改为当前位置。
4. 若遍历结束（遍历到enrty == null），则说明中间没有过期数据，要新增了。
   1. 在staleSlot位置插入<key，value>
   2. 若前面有要清理的调用（cleanSomeSlots（slotToExpunge）

#### ThreadLocal的过期key清理流程

1. 探测式清理

   expungeStaleEntry方法，主要是从当前entry往后清理，遇到null就停止

   1. 按顺序遍历散列数组
      1. 遇到过期的key把entry设为null
      2. 遇到没有过期的key，重新hash，尝试更新位置。

2. 启发式清理

   cleanSomeSlots() 方法，数组长度为n

   1. 从传入的位置开始向后遍历 log2（n)次
      1. 若遍历过程中没有过期key，次数--，直到次数为0
      2. 若遇到过期key则进行探测式清理，且次数重置为log2（n）次

#### ThreadLocal的扩容机制

1. 先进行探测式清理
2. 判断大小是否达到3/4的阈值
   1. size >= 3/4 * threshold 到达就resize扩容
3. resize扩容
   1. 大小更新为原来的两倍
   2. 遍历原来的散列表，重新计算元素的hash位置
   3. 更新阈值为原来的两倍

#### ThreadLocal.get详解

1. 通过key值找到散列表中的位置slot
2. 是否key一样
   1. key一致，直接返回
   2. key不一致，调用expungeStaleEntry方法，进行探测式清理，再往后查找，直到key一致。



# JVM虚拟机

### 对象

#### 对象的创建

1. 类加载检查

   当遇到new指令时，先检查指令的参数是否能在常量池中找到它的符号引用。若有引用，则去查找是否这个类被加载、解析和初始化过，如果没有就进行类的加载过程。

2. 分配内存

   在类加载完后，对象所需的内存大小已经确定。虚拟机为新生对象分配内存，即把一块确定大小的内存从Java堆中分配出来给对象。

   1. 指针碰撞方式，把用过的内存放到一边，另一边都是空闲内存，中间有一个分界指针。每次移动分界指针来获取指定大小内存。
   2. 空闲列表，虚拟机维护一个列表，记录那些内存块是空闲，在分配时，寻找一块可以放下对象的空闲区域划分给对象，记录在列表中。

   **内存分配的并发问题**（同时有多个对象进行分配内存）

   1. CAS+失败重试，CAS是一种乐观锁，假设没有冲突去执行操作，每次操作都不加锁，如果冲突就重试，直到成功。
   2. TLAB，为每个线程在Eden区中分配一些内存，先使用。如果不够用，就使用1的CAS+重试进行内存分配

3. 初始化零值

   内存分配完成后，需要把内存分配到的区域数据全部重新初始化零值，不包括对象头。

4. 设置对象头

   初始化零值后，需要对对象进行必要的信息设置，如是那个类的实例、元数据信息的地址，对象哈希码等信息。把这些信息存放到对象头中。

5. 执行init方法

   从虚拟机角度来看，对象已经生成完毕，但Java程序来看，对象还没执行init方法。执行完init方法才是按程序员的想法进行对象的初始化。得到真正可用的对象。

#### 对象的内存布局

1. 对象头

   1. 存储对象自身的运行数据（哈希码、GC分代年龄、锁标志）
   2. 类型指针，对象指向的类元数据指针。

2. 实例数据

   ​	程序中定义的字段

3. 填充数据

   ​	没有意义，只是因为虚拟机中是8字节的整数倍。

#### 对象的访问定位

1. 句柄

   Java堆中会划分出一块内存作为句柄池，reference中存放的是对象的句柄地址。句柄包括了对象实例数据的地址和类型数据的地址

   优点：reference中存放的是稳定的句柄地址，修改时只需要需要改句柄中的实例数据指针

2. 直接指针

   reference中存放的是对象的地址。

   优点：访问块，减少了一次指针定位的时间开销。

### OSR 栈上替换

OSR的全称是 On Stack Replacement。

#### 为什么要OSR？

某些热点代码，在解释执行的比较慢，需要进行编译后减少后面执行时的时间，因为编译执行的速度明显快于解释执行。但在这个编译替换的过程中，编译需要时间，解释器还在不断的解释执行后面的代码。就会导致当编译完成后，需要等下一次调用这个方法时才会把解释执行的代码替换为编译后的代码。但可能是个循环，调用一次就没了，但是循环还在不断进行，这时编译器就做了无用功。所以就需要OSR，它把解释器栈的数据打包到OSR buffer中，然后就执行OSR版本的代码。执行完后又回到低优化等级的代码中继续执行。

