## Thrift

#### 服务端

##### Processor

里面封装Handler类，这里写好处理逻辑。使用了TbaseProcessor

TbaseProcessor实现了TProcessor接口，先从输入获取方法名，然后从Map中找到对应的ProcessFunction实例，通过ProcessFunction进行调用。

##### ProcessFunction

在生成代码时，会为每一个方法都生成一个ProcessFunction

##### 协议 Protocol

TBinaryProtocol 二进制编码传输（默认）

可设置严格读和严格写，严格读写就是多了版本号

##### 服务端的模式

TThreadPoolServer（阻塞式）





## ehcache

#### 与redis不同点：

ehcache直接在虚拟机中缓存，比redis速度快，效率高，但是不利于分布式应用。

#### 配置和使用

通过ehcache.xml配置缓存的基本信息

使用

 	1. 先创建读取xml创建缓存管理器CacheManager
 	2. 通过CacheManager.getCache("name")获取缓存对象cache
 	3. Cache.put放入缓存键值对、get(key) 获取值对象。
 	4. 可以配置持久化，将在服务关闭时，把缓存写到硬盘上，下次进行读取。



## redis缓存

最大节点个数16384个

#### 基本数据类型

String、Hash、List、Set、Nset

#### 好处

1. redis是存在内存中，速度很快。
2. redis支持的数据类型多。
3. 支持事务的操作，操作都是原子性。
4. 有很多特性，比如过期自动删除等。



#### 缓存穿透问题

缓存穿透指用户不断的请求缓存和数据库都不存在的值，导致每次查询都需要去查询数据库，导致数据库压力变大。

##### 解决方案

1. 如果是请求本身非法，就在API入口进行过滤，对参数进行校验。
2. 若因为数据库中确实没有，就在redis中对于这个key设置一个默认值，并设置过期时间。
3. 使用布隆过滤器进行判断，若存在再往数据库查。



#### 缓存雪崩问题

指缓存中大量的数据到期，使很多请求都要访问数据库，导致数据库压力过大。

##### 解决方案

1. 可以通过均匀设置过期时间来解决，一个较大固定值和一个较小的随机值。
2. 进行缓存预热。在正式部署服务之前，先访问一遍数据库，
3. 限流降级，通过加锁或者队列，控制访问数据库的线程数量，让其他线程排队，控制请求速率。



#### 缓存击穿问题

指某个热点key过期了，但是同时有大量的并发请求要查询这个key，导致这些请求都到了DB层面

与雪崩的区别可能是 雪崩是多个key过期、击穿是一个key

##### 解决方案

1. 保证热点数据不过期，使用定时任务刷新热点数据
2. 访问慢设备时，从高并发转为低并发，使用互斥锁。



## 二级缓存

缓存一致性问题

更新策略

1. 先删除缓存，在更新数据库。可能会有删除后，还没更新之前，读到脏数据，然后缓存就一直没更新。
2. 先更新数据库，再删缓存，在更新时，可能会读到脏数据，但是下次就会恢复正常。
3. 异步更新缓存，数据库更新完成后，把操作命令封装问消息，让redis自己去更新数据。



## HTTP状态码

#### 1** 信息，服务器收到请求，需要请求者继续操作

#### 2** 成功，操作被成功接收和处理

- 200 OK 请求成功 用于post和get请求
- 201 created 创建成功 成功请求并且创建了新的资源
- 202 accepted 已接受，已接受了请求但还没处理完成
- 203 非授权信息，请求成功。返回的meta信息不在原始的服务器。
- 204 无内容，服务器成功处理。
- 205 重置内容 服务器处理成功，终端需要重置内容。
- 206 部分内容，服务器处理了部分Get请求

#### 3** 重定向，需要进一步操作来完成请求

- 300 多种选择，请求的资源包括多个位置。
- 301 永久移动，请求的资源已经被永久移动到新url
- 302 临时移动，与301类似，但是只是临时移动
- 303 查看其他地址。与301类似，使用Get和Post请求查看
- 304 未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
- 305 使用代理，所请求的资源必须通过代理
- 306 ❌已经被废弃
- 307 临时重定向，与302类似，使用Get请求重定向

#### 4** 客户端错误，请求包含错误或者无法处理请求

- 400 bad request 客户端请求的语法错误
- 401 请求要求用户的身份认证
- 402 保留☑️
- 403 拒绝请求，服务器能理解客户端的请求，但是拒绝执行了
- 404 服务器无法根据客户端的请求找到资源。
- 405 客户端请求的方法被禁止
- 406 服务器无法根据客户端的内容特性完成请求
- 407 请求要求代理的身份认证，与401类似。但请求者需要使用代理进行授权
- 408 服务器等待客户端发送的请求时间过长，超时
- 409 put请求的时候可能会返回，服务器处理请求发生了冲突
- 410 请求的资源已经不存在
- 411 客户端发送的请求需要带content-length
- 412 客户端请求信息的先决条件错误
- 413 请求的实体过大，服务器无法处理，因此拒绝请求。
- 414 请求的url过长，服务器无法处理。
- 415 服务器无法处理请求附带的媒体格式
- 416 客户端请求的范围无效
- 417 服务器无法满足expect的请求头信息

#### 5** 服务器错误，服务器在处理请求过程中发生了错误

- 500 服务器内部错误

- 501 服务器不支持请求

- 502 作为网关或者代理工作的服务器尝试执行请求，但是从远端服务器收到了无效的响应

- 503 由于超载或者系统维护，服务器暂时无法处理客户端请求

- 504 充当网关或代理的服务器，未及时从远端服务器获取请求

- 505 服务器不支持请求的http协议的版本。

  

## 重定向和跳转的区别

1. 请求次数不同，重定向用户会发送两次请求给服务器，而跳转是用户请求一次然后经过N个jsp界面后返回给用户浏览器
2. 跳转过程中的链接变化不同，重定向因为请求了两次，所以地址会变化。而跳转只请求了一次，所以地址没有变化
3. 目的不同，重定向只是单纯的跳转到新界面。而跳转是要得到用户的请求内容并且进行一部分的处理。



