

## 红黑树

- 基本限制条件：
   	1.  节点只能红或黑
   	2.  从任何节点向下遍历它的子孙的叶子结点，路径上的黑节点个数必须一样。
   	3.  根节点和空节点是黑色。
   	4.  不能同时有两个红色节点相连。

- 查询操作

  终止条件：找到空节点或目标节点就返回

  1. 相等就返回
  2. 小于向左找
  3. 大于向右找

- 插入操作

  - 查找过程：

    比较当前节点大小，找到叶子节点，再次比较，大于放叶子节点右边，小于放左边。

    - 小的向左节点找
    - 大的向右节点找

    需要注意底部插入后，可能祖父节点不平衡，就要从祖父节点继续下面的插入修复操作。

  - 插入修复操作 （插入点为开始为红色）

  - - 父节点为黑色，直接插入。

    - 父节点为红色

      1. 叔叔节点是红色
         1. 把父节点和叔叔节点的颜色和祖父节点颜色互换。
         2. 然后祖父节点也这样判断，不断往上修改颜色。

      2. 叔叔节点为空或黑、祖父节点、父节点、新节点在一条斜线上（以左边为例）
         1. 右旋操作 （此时祖父节点为黑色和父亲节点为红色）
         2. 把父节点替换到祖父节点位置，祖父节点变为右儿子（交换祖父和父节点的颜色）
      3. 叔叔节点为空或黑、祖父节点、父节点、新节点不在一条斜线上（以祖父、父节点在左边、新节点在右边为例）
         1. 先进行左旋，新节点提升为父节点、父节点变为左儿子。
         2. 执行完后变为第二种情况，使用第二种的操作。

 - 删除操作

   - 叶子节点

     红色的直接删除即可，不需要调整。

     黑色需要进行删除修复操作

   - 非叶子节点

     通过替换为中序遍历的后一个数字，就可以转化为叶子节点的删除。

   - 删除修复操作（遇到根结点或者红节点就停止）以左子树要删掉为例，

     1. 兄弟节点是红色，设置兄弟的左节点为兄弟节点的颜色，进行一次左旋（兄弟提升到父节点，父节点变为左子树）

     2. 兄弟节点是黑色

        1. 兄弟节点的儿子为两个红，把兄弟的右子树变父亲颜色，交换兄弟和父亲节点的颜色，进行一次左旋。

           交换颜色，保证兄弟节点升为父亲后上一级不被影响。

        2. 兄弟节点的右儿子为红，右儿子的颜色变为兄弟节点颜色，交换兄弟和父亲颜色。然后左旋，把兄弟节点变为父节点

           变红的原因是原来的父节点是红色，左旋后兄弟节点升为父节点也需要是红色。

        3. 兄弟节点的左儿子为红，先交换左儿子和兄弟的颜色，然后再右旋变为一条线，然后就和情况2一样了。

        4. 兄弟节点没有儿子，把兄弟节点变为红色，然后父节点递归往上尝试修复。知道遇到红色节点或者根结点



## AVL树

- 基本条件：
  1. 所有子树的左右树高不能相差超过1

- 查询条件：

  终止条件：找到空节点或目标节点就返回

  1. 相等就返回
  2. 小于向左找
  3. 大于向右找

- 插入操作

  1. 先寻找要插入的位置。类似查询操作

  2. 插入后计算左右子树的高度差，如果大于1则进行旋转操作。不断往上判断，直到根结点

     包括四种情况

     1. 左左LL（左子树高然后插入到左子树的左儿子上），进行右旋即可
     2. 左右LR，先进行左旋把LR变为LL情况，然后右旋
     3. 右左RL，先右旋变为RR情况，在左旋
     4. 右右RR，直接左旋即可。

- 删除操作

  1. 先找到要删除的节点

     1. 叶子节点：直接删

     2. 非叶子节点

        - 有且只有一个孩子，直接孩子顶替

        - 有两个孩子，该节点替换为前驱或后继节点。然后变为递归删掉替换的节点

           当左子树高为前驱、右子树高为后继

  2. 然后计算左右子树高度，高度不同就进行旋转调整。



## 比较红黑树和AVL树

1. 实现机制不同

   红黑树通过颜色变化和旋转来保持平衡

   AVL通过树高和旋转来保持平衡

2. 插入效率不同

   红黑树的旋转次数可以保证在3次以内，效率比较高，因为不是严格的平衡，是局部的平衡

   AVL树需要可能需要更多的旋转次数来保证树的严格平衡。

3. 查找效率不同

   AVL因为严格平衡所以查询效率高。

4. 使用场景

   红黑树因为插入和删除时的旋转次数比AVL树少，所以在插入和删除场景比较多的时候使用。

   如果都是查询很少插入和删除的话 还是使用AVL树。

   

## B树

- 基本条件：（以m阶B树为例）

  1. 每个节点最多m个字节点
  2. 除了根节点外，每个非叶子节点至少m/2（向下取整）个子节点
  3. 非叶子节点的根节点至少有2个子节点
  4. K颗子树的非叶子节点有k-1个键，递增排序。
  5. 叶子节点都在同一层

- 查询

  根据要找的key。从根节点出发向下查找。

  在关键码集合中使用顺序或者二分查找到最接近的key，

  ​	相等说明找到了直接返回。

  ​	不相等就一定在某个ki 和ki+1之间继续从这个子树查找。直到指针为空或者找到

- 插入操作

  先使用查询操作，查找这个节点。

  - 找到就更新
  - 没有找到就到了叶子节点处，尝试插入元素
    - 若当前节点元素个数小于m-1、直接插入
    - 等于m-1，进行分裂。以节点的中间元素为分割点，左一半、中间、右一半。中间的元素尝试插入到父节点。
    - 不断重复直到符合B树规则。

- 删除操作

  先查询要删除的节点。

  - 若节点没有左右节点、直接删
  - 若节点有左右节点，删掉节点后，需要把左/右节点的相近元素上移到这个节点的位置。

  删除后可能节点会不符合B树的条件需要调整

  - 若某节点中的个数小于（m/2) -1 的话，则需要看看相邻的兄弟节点是否丰满（节点元素大于（m/2） -1）

    - 丰满的话，就借一个元素给该节点。

    - 不丰满的话即节点个数正好等于（m/2)-1，要尝试进行合并该节点和他相临的兄弟节点为一个节点。

      ​	合并后父亲节点会少一个节点，可能会再次触发调整。



## B + 树

- 基本条件：（以m阶B+树为例）

  1. 每个节点最多有m个子节点
  2. 除了根节点外，每个节点至少有（m/2 向下取整）个节点
  3. 非叶子节点至少有2个子节点
  4. 有k颗子树的节点有k个键，按递增排序
  5. 叶节点在同一层（只有叶节点存放数据，中间节点只存放索引）

- 查询

  从根节点往下找，比较关键码的大小，但是B+树会不断比较直到到达叶子节点才会停止。

- 插入

  先查询找到要插入的叶子节点位置

  	- 若插入后节点个数小于m则结束。
  	- 若插入后节点的个数超过m个则进行分裂，分裂为 （m+1)/2  的两个大小。中间的节点作为索引节点复制索引到父节点的。
  	- 父节点添加新索引后需要判断是否需要继续分裂。

- 删除

  ​	先查询找到需要删掉的叶子节点位置。删掉叶子节点。

  - 删除后导致节点中的个数小于m/2时，需要进行兄弟的合并。
    - 若左右兄弟都是丰满的，则借一个节点给该节点。
    - 若左右兄弟不是丰满的，则合并左/右兄弟，（有时候需要修改父节点中的索引值）



## Thrift

#### 服务端

##### Processor

里面封装Handler类，这里写好处理逻辑。使用了TbaseProcessor

TbaseProcessor实现了TProcessor接口，先从输入获取方法名，然后从Map中找到对应的ProcessFunction实例，通过ProcessFunction进行调用。

##### ProcessFunction

在生成代码时，会为每一个方法都生成一个ProcessFunction

##### 协议 Protocol

TBinaryProtocol 二进制编码传输（默认）

可设置严格读和严格写，严格读写就是多了版本号

##### 服务端的模式

TThreadPoolServer（阻塞式）





## ehcache

#### 与redis不同点：

ehcache直接在虚拟机中缓存，比redis速度快，效率高，但是不利于分布式应用。

#### 配置和使用

通过ehcache.xml配置缓存的基本信息

使用

 	1. 先创建读取xml创建缓存管理器CacheManager
 	2. 通过CacheManager.getCache("name")获取缓存对象cache
 	3. Cache.put放入缓存键值对、get(key) 获取值对象。
 	4. 可以配置持久化，将在服务关闭时，把缓存写到硬盘上，下次进行读取。



## redis缓存

最大节点个数16384个

#### 基本数据类型

String、Hash、List、Set、Nset

#### 好处

1. redis是存在内存中，速度很快。
2. redis支持的数据类型多。
3. 支持事务的操作，操作都是原子性。
4. 有很多特性，比如过期自动删除等。



#### 缓存穿透问题

缓存穿透指用户不断的请求缓存和数据库都不存在的值，导致每次查询都需要去查询数据库，导致数据库压力变大。

##### 解决方案

1. 如果是请求本身非法，就在API入口进行过滤，对参数进行校验。
2. 若因为数据库中确实没有，就在redis中对于这个key设置一个默认值，并设置过期时间。
3. 使用布隆过滤器进行判断，若存在再往数据库查。



#### 缓存雪崩问题

指缓存中大量的数据到期，使很多请求都要访问数据库，导致数据库压力过大。

##### 解决方案

1. 可以通过均匀设置过期时间来解决，一个较大固定值和一个较小的随机值。
2. 进行缓存预热。在正式部署服务之前，先访问一遍数据库，
3. 限流降级，通过加锁或者队列，控制访问数据库的线程数量，让其他线程排队，控制请求速率。



#### 缓存击穿问题

指某个热点key过期了，但是同时有大量的并发请求要查询这个key，导致这些请求都到了DB层面

与雪崩的区别可能是 雪崩是多个key过期、击穿是一个key

##### 解决方案

1. 保证热点数据不过期，使用定时任务刷新热点数据
2. 访问慢设备时，从高并发转为低并发，使用互斥锁。



## 二级缓存

缓存一致性问题

更新策略

1. 先删除缓存，在更新数据库。可能会有删除后，还没更新之前，读到脏数据，然后缓存就一直没更新。
2. 先更新数据库，再删缓存，在更新时，可能会读到脏数据，但是下次就会恢复正常。
3. 异步更新缓存，数据库更新完成后，把操作命令封装问消息，让redis自己去更新数据。



## HTTP状态码

#### 1** 信息，服务器收到请求，需要请求者继续操作

#### 2** 成功，操作被成功接收和处理

- 200 OK 请求成功 用于post和get请求
- 201 created 创建成功 成功请求并且创建了新的资源
- 202 accepted 已接受，已接受了请求但还没处理完成
- 203 非授权信息，请求成功。返回的meta信息不在原始的服务器。
- 204 无内容，服务器成功处理。
- 205 重置内容 服务器处理成功，终端需要重置内容。
- 206 部分内容，服务器处理了部分Get请求

#### 3** 重定向，需要进一步操作来完成请求

- 300 多种选择，请求的资源包括多个位置。
- 301 永久移动，请求的资源已经被永久移动到新url
- 302 临时移动，与301类似，但是只是临时移动
- 303 查看其他地址。与301类似，使用Get和Post请求查看
- 304 未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
- 305 使用代理，所请求的资源必须通过代理
- 306 ❌已经被废弃
- 307 临时重定向，与302类似，使用Get请求重定向

#### 4** 客户端错误，请求包含错误或者无法处理请求

- 400 bad request 客户端请求的语法错误
- 401 请求要求用户的身份认证
- 402 保留☑️
- 403 拒绝请求，服务器能理解客户端的请求，但是拒绝执行了
- 404 服务器无法根据客户端的请求找到资源。
- 405 客户端请求的方法被禁止
- 406 服务器无法根据客户端的内容特性完成请求
- 407 请求要求代理的身份认证，与401类似。但请求者需要使用代理进行授权
- 408 服务器等待客户端发送的请求时间过长，超时
- 409 put请求的时候可能会返回，服务器处理请求发生了冲突
- 410 请求的资源已经不存在
- 411 客户端发送的请求需要带content-length
- 412 客户端请求信息的先决条件错误
- 413 请求的实体过大，服务器无法处理，因此拒绝请求。
- 414 请求的url过长，服务器无法处理。
- 415 服务器无法处理请求附带的媒体格式
- 416 客户端请求的范围无效
- 417 服务器无法满足expect的请求头信息

#### 5** 服务器错误，服务器在处理请求过程中发生了错误

- 500 服务器内部错误

- 501 服务器不支持请求

- 502 作为网关或者代理工作的服务器尝试执行请求，但是从远端服务器收到了无效的响应

- 503 由于超载或者系统维护，服务器暂时无法处理客户端请求

- 504 充当网关或代理的服务器，未及时从远端服务器获取请求

- 505 服务器不支持请求的http协议的版本。

  

## 重定向和跳转的区别

1. 请求次数不同，重定向用户会发送两次请求给服务器，而跳转是用户请求一次然后经过N个jsp界面后返回给用户浏览器
2. 跳转过程中的链接变化不同，重定向因为请求了两次，所以地址会变化。而跳转只请求了一次，所以地址没有变化
3. 目的不同，重定向只是单纯的跳转到新界面。而跳转是要得到用户的请求内容并且进行一部分的处理。



