# MySql

## 索引

### 索引类型

1. 主键索引

2. 二级索引（辅助索引）

   1. 唯一索引，一张表允许多个唯一索引，唯一索引表示的列不能有重复值。主要用来唯一性的保证。数据可以为NULL
   2. 普通索引， 该列元素可以重复、为NULL，作用主要用来快速查询数据，
   3. 前缀索引，只适用于字符串类型的数据，对文本的前几个字符进行索引，比普通索引建立的数据小。
   4. 全文索引，为了检索大文本数据中的关键字信息。

3. 覆盖索引

   如果一个索引包含了所有需要查询的字段就称为覆盖索引。

4. 聚簇索引和非聚簇索引

   聚簇表示节点包含了索引和数据，非聚簇表示只包含了索引。要找到具体数据还要进行回表。

5. 联合索引

   使用多个字段进行索引。

### 建立索引需要注意什么

索引的建立需要消耗大量资源

1. 大量重复的字段不要建索引
2. 少量数据不要
3. 没有标示作用的字段不要建索引
4. 经常更新的字段不要建索引，会导致B+树不断的进行维护产生大量开销。
5. 字符串上使用前缀索引代替普通索引
6. 尽可能考虑联合索引，而不是单列索引。
7. 需要频繁排序的字段，可以建立索引，利用索引来加速排序查询。
8. 经常作为条件判断的字段，应该被考虑作为索引。

### 索引优化

1. 前缀索引优化

   通过前缀索引优化，可以减少索引字段大小，但是也有局限性：1.无法进行覆盖索引，2.orderby就无法使用前缀索引

2. 覆盖索引优化

   合理设置索引，让覆盖索引生效，从而避免回表

3. 主键自增

   因为innodb默认使用聚簇索引，数据被放到B+树的节点上，B+树的同一节点内的数据是按主键顺序存放的，因此如果有新的数据进来，会根据主键值放到对应位置。使用自增主键可以使每次插入的数据都会按顺序添加到新位置，不用移动原来的数据。

4. 防止索引失效

   1. 当使用like 模糊匹配时，索引会失效
   2. 对查询条件使用函数时，会失效
   3. 对于联合索引，需要注意左匹配原则，否则会失效
   4. 在Where字句中，OR前面使用索引字段，OR后面不是索引列，会导致失效。



## 事务

### 隔离等级

1. 读取未提交

   脏读、不可重复读、幻读

2. 读取已提交

   不可重复读、幻读

3. 可重复读

   幻读

4. 可串行化

### 四大特性

1. 原子性
2. 隔离性
3. 持久性
4. 一致性

### 多版本并发控制MVCC

基本组成：

- 隐藏列

  - 最后一个事务的ID DB_TRX_ID
  - undo日志的指针，指向旧版本的数据

- Read View

  - 事务最小ID，当前活跃事务的最小id

  - 事务最大ID，数据库给下一个事务的ID

  - 活跃事务ID列表，在创建Read View时活跃的事务列表ID

  - 创建该ReadView 的事务ID

    

可见性判断流程

1. 比较当前记录的 最后事务ID 是否小于事务最小ID，小于则可见

2. 比较当前记录的 最后事务ID是否大于事务最大ID，大于则不可见

3. 查询当前记录的最后事务ID，是否在活跃列表中：在的话不可见/ 不在的话可见

4. 对于不可见的都需要去找旧版本的可见数据来返回。

   1. 通过undo日志的指针，往前找版本，然后重新进行可见性判断。直到可见。

   

- 读已提交

  在一个事务中，每次查询都会新建一个Read View

- 可重复读

  在一个事务中，只会在第一次查询时新建一个Read View

- 在当前读情况下的幻读

  使用next-key锁 = 行锁+ 间隙锁

  

## 锁

### 锁的类型

- 全局锁

  

- 表级锁

  1. 表锁

  2. 意向锁

     在对某些记录尝试加载共享锁/独占锁时，需要先在表上申请到对应的意向共享锁/意向独占锁。

     方便添加表锁，不需要再挨个记录判断是否被添加了行级的共享/独占锁了

- 行级锁

  1. 记录锁 record lock，用锁住单个记录

  2. 间隙锁 gao lock，用来锁住一个范围内，不包括自己

  3. 临键锁 nextkey lock，锁定一个范围，包括自己（record lock + gap lock）

     

### 如何加锁 （next key lock）

next-key lock在不同情况下会退化为记录锁、间隙锁

- 唯一索引等值查询
  1. 没找到值：退化为间隙锁
  2. 找到值：退化为记录锁
- 唯一索引范围查询
  1. 没找到：退化为间隙锁
  2. 找到：退化为记录锁
- 非唯一索引等值查询
  		1. 没找到：退化为间隙锁
  		1. 找到：找到时的临键锁保持，因为找到了还会加上间隙锁

- 非唯一索引范围查询
  		1. 找到/没找到：都会保持临键锁



### innoDB解决幻读

- 快照读，通过MVCC来保证不会幻读

  快照读：如果读取的数据正在进行update/delete操作，读取操作不会等待独占锁的释放，而是转而读取一个快照

- 当前读，通过next key lock来保证不会幻读

  当前读：读取的是最新提交的数据



## 日志

### binlog 二进制日志



### redo log 事务日志

binlog是innoDB存储引擎特有的，使数据库具有崩溃恢复能力

- 什么时候进行记录

MySql中数据是以页为单位，查询一条记录会把一页的数据加载出来。放入缓冲池buffer pool中。查询都是先从缓冲池中找，没有命中才去数据库。更新时也是先更新到buffer pool中，然后会把这个更新记录到redo log buffer中，然后刷盘到redo log 文件中。

- 刷盘时机

  - 提供了innodb_flush_log_at_trx_commit有三个参数：

    0:提交事务后不刷盘

    1:每次提交事务都刷盘（默认） 

    2:每次提交事务都把缓冲区的数据放入page cache中

  - InnoDB有一个后台线程，

    - 每隔1秒都会把redo log buffer中的数据写到文件缓冲系统（page cache）中。然后fsync刷盘
    - 或者当redo log buffer的空间达到一班时，也会进行主动刷盘

- 日志文件组

​		硬盘上的redo log日志不止一个，是以日志组的形式

### undo log回滚日志





# Redis

### 对比Redis和Memcached

#### 相同点

1. 都在内存中，速度很快可以作为缓存使用。

     		2.  都有过期策略。
  		3.  性能很高

#### 不同点

1. Redis有原生的集群模式，Memcached没有
2. Redis支持事务、Lua脚本、订阅模型等。Memcached没有。
3. Redis可以进行持久化到磁盘，Memcached没有。
4. Redis可以支持复杂的数据存储，Memcached只有key-value模型

### 线程模型

redis并不是单线程的，包括了一个主线程，和三个后台线程（AOF刷盘、关闭文件、释放内存）

### Redis的持久化

1. AOF刷盘，每次执行一条写命令，都将它存入AOF文件用于恢复。

1. RDB快照，将某一时刻的内存数据，以二进制的形式写入磁盘。
2. 混合模式，Redis4.0新增的方式。

### AOF （append only file）

先执行完一条写命令后，在执行记录命令

* Question：为什么先执行写命令，在执行记录日志命令？

  * Answer

    好处

    1. 可以避免检查命令正确性的开销，每次写命令执行成功后才会写入日志。
    2. 不会阻塞写命令的执行。

    坏处

    1. 可能会丢失数据，因为是分开执行的，所有如果在执行完写命令后服务宕机，会导致这次的写入没有保存。
    2. 会阻塞其他命令的执行。因为AOF日志也是在主线程中执行的，在写入磁盘的时候，主线程就无法执行其他命令了。

* 具体说说如何记录？

  * 执行完写命令后，先将命令追加到aof buf中。
  * 然后将aof buf中的数据复制到内核区的缓冲区page cache。
  * 然后由内核决定什么时候把缓冲区的数据写入硬盘

* Question：Redis有几种写入硬盘的策略？

  1. Always 及时写回，每次都直接写回去。
  2. Everysec 每秒写回，每隔一秒写回去。
  3. No 不由redis控制，意味着由操作系统自己控制什么时候把缓存区的数据写入内核。
  
* Question：AOF文件太大怎么办？

  * 有AOF重写机制，当AOF文件过大时，会将当前内存中的键值对全部写入一个《新的AOF文件》中，然后替换掉现在过大的AOF文件。相对于压缩了AOF文件。

#### AOF重写机制

AOF重写由《子进程》bgrewriteaof来完成。触发AOF重写机制后，主进程会创建子进程，由这个子进程对内存进行只读操作，并将键值对转为命令存入AOF文件中。

* 由子进程完成有什么好处？
  1. 主线程可以继续执行其他任务，减少了阻塞。
  2. 由进程的形式来处理，可以减少不必要的加锁开销，子进程会复制父进程的数据，并且当父子双发任意一方修改了内存，都会发生《写时复制》让父子进程有各自独立的数据副本保证数据安全。
* Question：AOF重写过程可能存在数据不一致问题怎么办？
  * Redis设置了《AOF重写缓冲区》，在处于重写阶段后会被使用，每次Redis执行完写命令后都会追加到《AOF重写缓冲区》中，当子进程读取完所有键值对后，在把《AOF重写缓冲区》中的数据追加到<AOF文件>中即可。