## 数据库基本概念

### 并发事务的问题

1. 脏读
2. 丢失修改
3. 不可重复读
4. 幻读



### 事务的隔离等级

1. 读取未提交
2. 读取已提交
3. 可重复读
4. 可串行化

### 事务的四大特性

1. 原子性
2. 隔离性
3. 持久性
4. 一致性



### 建立索引需要注意什么

索引的建立需要消耗大量资源

1. 大量重复的字段不要建索引
2. 少量数据不要
3. 没有标示作用的字段不要建索引
4. 经常更新的字段不要建索引，会导致B+树不断的进行维护产生大量开销。

## Redis

### 对比Redis和Memcached

#### 相同点

1. 都在内存中，速度很快可以作为缓存使用。

     		2.  都有过期策略。
  		3.  性能很高

#### 不同点

1. Redis有原生的集群模式，Memcached没有
2. Redis支持事务、Lua脚本、订阅模型等。Memcached没有。
3. Redis可以进行持久化到磁盘，Memcached没有。
4. Redis可以支持复杂的数据存储，Memcached只有key-value模型

### 线程模型

redis并不是单线程的，包括了一个主线程，和三个后台线程（AOF刷盘、关闭文件、释放内存）

### Redis的持久化

1. AOF刷盘，每次执行一条写命令，都将它存入AOF文件用于恢复。

1. RDB快照，将某一时刻的内存数据，以二进制的形式写入磁盘。
2. 混合模式，Redis4.0新增的方式。

### AOF （append only file）

先执行完一条写命令后，在执行记录命令

* Question：为什么先执行写命令，在执行记录日志命令？

  * Answer

    好处

    1. 可以避免检查命令正确性的开销，每次写命令执行成功后才会写入日志。
    2. 不会阻塞写命令的执行。

    坏处

    1. 可能会丢失数据，因为是分开执行的，所有如果在执行完写命令后服务宕机，会导致这次的写入没有保存。
    2. 会阻塞其他命令的执行。因为AOF日志也是在主线程中执行的，在写入磁盘的时候，主线程就无法执行其他命令了。

* 具体说说如何记录？

  * 执行完写命令后，先将命令追加到aof buf中。
  * 然后将aof buf中的数据复制到内核区的缓冲区page cache。
  * 然后由内核决定什么时候把缓冲区的数据写入硬盘

* Question：Redis有几种写入硬盘的策略？

  1. Always 及时写回，每次都直接写回去。
  2. Everysec 每秒写回，每隔一秒写回去。
  3. No 不由redis控制，意味着由操作系统自己控制什么时候把缓存区的数据写入内核。
  
* Question：AOF文件太大怎么办？

  * 有AOF重写机制，当AOF文件过大时，会将当前内存中的键值对全部写入一个《新的AOF文件》中，然后替换掉现在过大的AOF文件。相对于压缩了AOF文件。

#### AOF重写机制

AOF重写由《子进程》bgrewriteaof来完成。触发AOF重写机制后，主进程会创建子进程，由这个子进程对内存进行只读操作，并将键值对转为命令存入AOF文件中。

* 由子进程完成有什么好处？
  1. 主线程可以继续执行其他任务，减少了阻塞。
  2. 由进程的形式来处理，可以减少不必要的加锁开销，子进程会复制父进程的数据，并且当父子双发任意一方修改了内存，都会发生《写时复制》让父子进程有各自独立的数据副本保证数据安全。
* Question：AOF重写过程可能存在数据不一致问题怎么办？
  * Redis设置了《AOF重写缓冲区》，在处于重写阶段后会被使用，每次Redis执行完写命令后都会追加到《AOF重写缓冲区》中，当子进程读取完所有键值对后，在把《AOF重写缓冲区》中的数据追加到<AOF文件>中即可。